package cli

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/peter941221/secrethawk/internal/model"
	"github.com/spf13/cobra"
)

func newReportCommand() *cobra.Command {
	var (
		input    string
		output   string
		operator string
	)

	cmd := &cobra.Command{
		Use:   "report",
		Short: "Generate incident report",
		RunE: func(cmd *cobra.Command, args []string) error {
			if input == "" {
				return &ExitError{Code: 2, Message: "--input is required (scan JSON output)"}
			}
			report, err := loadFindingReport(input)
			if err != nil {
				return &ExitError{Code: 2, Message: err.Error()}
			}
			if len(report.Findings) == 0 {
				return &ExitError{Code: 2, Message: "no findings in input report"}
			}

			if output == "" {
				now := time.Now().UTC().Format("2006-01-02-150405")
				output = filepath.Join(".secrethawk", "reports", now+".md")
			}
			if err := os.MkdirAll(filepath.Dir(output), 0o755); err != nil {
				return &ExitError{Code: 2, Message: err.Error()}
			}

			body := renderIncidentReport(report, operator)
			if err := os.WriteFile(output, []byte(body), 0o644); err != nil {
				return &ExitError{Code: 2, Message: err.Error()}
			}
			fmt.Fprintf(cmd.OutOrStdout(), "report generated: %s\n", output)
			return nil
		},
	}

	cmd.Flags().StringVar(&input, "input", "", "Input scan findings JSON file")
	cmd.Flags().StringVar(&output, "output", "", "Output markdown path")
	cmd.Flags().StringVar(&operator, "operator", "unknown", "Operator name/email")
	return cmd
}

func renderIncidentReport(scanReport model.FindingReport, operator string) string {
	first := scanReport.Findings[0]
	generatedAt := time.Now().UTC().Format(time.RFC3339)
	id := "INC-" + time.Now().UTC().Format("20060102-150405")

	var b strings.Builder
	b.WriteString("# Secret Leak Incident Report\n\n")
	b.WriteString(fmt.Sprintf("**Report ID:** %s  \n", id))
	b.WriteString(fmt.Sprintf("**Generated by:** SecretHawk %s  \n", scanReport.Metadata.Version))
	b.WriteString(fmt.Sprintf("**Generated at:** %s  \n\n", generatedAt))
	b.WriteString("## Summary\n\n")
	b.WriteString("| Field | Value |\n")
	b.WriteString("|-------|-------|\n")
	b.WriteString(fmt.Sprintf("| Secret Type | %s |\n", first.RuleName))
	b.WriteString(fmt.Sprintf("| Severity | %s |\n", strings.ToUpper(first.Severity)))
	b.WriteString(fmt.Sprintf("| File | `%s:%d` |\n", first.Location.File, first.Location.LineStart))
	if first.Location.Commit != nil {
		b.WriteString(fmt.Sprintf("| Commit | `%s` |\n", *first.Location.Commit))
	} else {
		b.WriteString("| Commit | `(workspace)` |\n")
	}
	b.WriteString(fmt.Sprintf("| Operator | %s |\n", operator))
	b.WriteString(fmt.Sprintf("| Detected | %s |\n", scanReport.Metadata.ScannedAt.Format(time.RFC3339)))
	b.WriteString("\n## Actions Taken\n\n")
	b.WriteString("- [x] Secret identified and triaged\n")
	b.WriteString("- [ ] Credential rotated/revoked\n")
	b.WriteString("- [ ] Code and CI references patched\n")
	b.WriteString("- [ ] Git history cleanup completed\n")
	b.WriteString("\n## Findings\n\n")
	for i, f := range scanReport.Findings {
		b.WriteString(fmt.Sprintf("### %d. %s\n\n", i+1, f.RuleName))
		b.WriteString(fmt.Sprintf("- Severity: `%s`\n", f.Severity))
		b.WriteString(fmt.Sprintf("- Location: `%s:%d`\n", f.Location.File, f.Location.LineStart))
		b.WriteString(fmt.Sprintf("- Match (redacted): `%s`\n", f.Match.RawRedacted))
		b.WriteString(fmt.Sprintf("- Validation: `%s`\n\n", f.Validation.Status))
	}

	return b.String()
}
